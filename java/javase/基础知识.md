# Java基础知识

## 1.Object类

Object类是Java中所有类的超类，每个类都间接或直接继承了Object，但是并不需要写extends。如果没有明确指出超类，Object就被认为是这个类的超类。

### 1.equals方法

object类中的equals方法用于检测一个对象是否等于另外一个对象。Object类中实现的equals方法将确定两个对象引用是否相等。代码如下：

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

Java给出一个完美编写equals方法的建议：

* 1.显示参数命名为otherObject，稍后需要将它强制转换成另一个other的变量。

* 2.检测this与otherObject是否相等

  ```java
  if (this == otherObject) return true;
  ```

  这条语句只是一个优化，实际上，这是经常采用的方式。因为检查身份要比逐个比较字段开销小。

* 3.检测otherObject是非为null，如果为null，返回false。

  ```java
  if (otherObject == null) return false;
  ```

* 4.比较this与otherObject的类。

  ```java
  if (getClass() != otherObject.getClass()) return false;
  ```

* 5.将otherObject强制转换为相应类型的变量；

  ```java
  ClassName other = (ClassName) otherObject;
  ```

* 现在根据相等性的概念来比较字段。使用==比较基本类型，使用Objects.equals比较对象字段。

  ```java
  return field1 == other.field1
      && Objects.equals(field2, other.field2)
      && ...;
  ```

### 2.hashCode方法

散列码（hash code）是由对象导出的一个整型值。散列码是没有规律的。如果两个对象不同，则散列码基本上不同。相同字符串的散列码相同，这是因为字符串的散列码是由内容导出的，String类使用一下算法计算散列码：

```java
int hash = 0;
for (int i = 0; i < value.length; i++) {
    hash = 31 * hash + value[i];
}
```

如果重新定义了equals方法，就必须为用户可能插入散列表的对象重新定义hashCode方法。hashCode方法应该返回一个整数（也可以是负数）。要合理地组合实例字段的散列码，以便能够让不同对象产生的散列码分布更加均匀。最好使用null安全的方法Objects.hashCode。更好的做法是，需要组合多个散列值时，可以调用Objects.hashCode并提供所有这些参数。这个方法会对各个参数调用Objects.hashCode，并组合这些散列值，如下：

```java
public int hashCode() {
    return Objects.hash(id, name, capital);
}
```

如果存在数组类型的字段，可以使用静态的Arrays.hashCode方法计算一个散列码，这个散列码由数组元素的散列码组成。

### 3.toString方法

Object的toString方法返回表示对象值的一个字符串。随处可见的toString方法的主要原因是：只要对象与一个字符串通过操作符“+”连接起来，Java编译器就会自动地调用toString方法来获得这个对象的字符串描述。强烈建议为自定义的每一个类添加toString方法。这样做不仅自己收益，所有使用这个类的程序员也会从这个日志记录支持中受益匪浅。

Object类的toString方法：

```java
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

正常的自定义toString方法：

```java
@Override
public String toString() {
    return "City{" +
        "id='" + id + '\'' +
        ", name='" + name + '\'' +
        '}';
}
```

实际上，也可以设计的更好一些，最好调用getClass().getName获得类名的字符串。如下：

```java
@Override
public String toString() {
    return getClass().getName +
        "{" +
        "id='" + id + '\'' +
        ", name='" + name + '\'' +
        '}';
}
```