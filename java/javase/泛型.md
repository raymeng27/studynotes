# 泛型

> 泛型程序设计意味着编写的代码可以对多种不同类型的对象重用。泛型的好处是：①在获取值时不需要进行强制转换类型，②有错误检查。

#  一、泛型介绍

## 1.定义简单泛型类

泛型类就是有一个或多个类型变量的类。例如：

```java
public class Pair<T> {

    private T first;
    private T second;

    public Pair() {}

    public Pair(T first, T second) {this.first = first; this.second = second;}

    public T getFirst() {return first;}

    public void setFirst(T first) {this.first = first;}

    public T getSecond() {return second;}

    public void setSecond(T second) {this.second = second;}
}
```

Pair类引入了一个类型变量T，用尖括号括起来，放在类名的后面。泛型类可以有很多个类型变量。例如，可以定义Pair类，其中第一个字段和第二个字段使用不同的类型：`public class Pair<T, U> {...}`，类型变量在整个类定义中用于指定方法的返回类型以及字段和局部变量的类型。例如：`private T first;`

## 2.泛型方法

还可以定义一个带有类型参数的方法：

```java
class ArrayAlg {
    public static <T> T getMiddle(T... a) {
        return a[a.length / 2];
    }
}
```

类型变量放在修饰符的后面，并在返回类型的前面。泛型方法可以在普通方法类中定义，也可以在泛型类中定义。当调用一个泛型方法时，可以把具体类型包围在尖括号中，放在方法名前面：

```java
String minddle = ArrayAlg.<String>getMiddle("Ho","s","a");
```

## 3.类型变量的限定

有时，类或方法需要对类型变量加以约束，如下：

```java
class ArrayAlg {
    public static <T> t min(T[] a) {
        if(a == null || a.length == 0) return null;
        T smallest = a[0];
        for (int i = 1; i < a.length; i++;)
            if(smallest.compareTo(a[i]) > 0) smallest = a[i];
        return smallest
    }
}
```

在例子中可以限制T只能是实现了Comparable接口的类。可以通过对类型变态T设置了一个限定（bound）来实现：

```java
public static <T extends Comparable> T min(T[] a)...
```

一个类型变量或通配符可以有多个限定，例如：`T extends Cpmparable & Serializable`，限定类用&分隔，而逗号用来分隔类型变量。

## 4.泛型代码与虚拟机

### 1.类型擦除

无论何时定义一个泛型类型，都会自动提供一个相应的原始类型。这个原始类型的名字就是去掉类型参数后的泛型类型名。类型变量会被擦除，并替换为其限定类型例如，Pair<T>的原始类型的变量则替换为Object：

```java
public class Pair {

    private Object first;
    private Object second;

    public Pair() {}

    public Pair(Object first, Object second) {this.first = first; this.second = second;}

    public Object getFirst() {return first;}

    public void setFirst(T first) {this.first = first;}

    public Object getSecond() {return second;}

    public void setSecond(T second) {this.second = second;}
}
```

因为T是一个无限定的变量，所以直接用Object替换。结果是一个普通的类，就好像Java语言中引入泛型之前实现的类一样。如果有多个限制类型，如：

```java
public class Interval<T extends Comparable & Serializable> {
    private T lower;
    private T upper;
}
```

原始类型为：

```java
public class Interval {
    private Comparable lower;
    private Comparable upper;
}
```

原始类型会按顺序改变，为了提高效率，应该将没有方法的接口放在限定列表的结尾。

对应Java泛型的转换，需要记住一下几个事实：

* 虚拟机中没有泛型，只有普通的类和方法。
* 所有的类型参数都会替换为它们的限定类型。
* 会合成桥方法来保持多态。
* 为保持类型安全性，必要时会插入强制类型转换。

## 5.限制与局限性

### 1.不能用基本类型实例化类型参数

不能用基本类型实例化类型参数。原因在于类型擦除。擦除之后，Pair类含有Object类型的字段，而Object不能存储基本类型的值。

### 2.运行时类型查询只适用于原始类型

虚拟机中的对象总有一个特定的非泛型类型。因此，所有的类型查询只产生原始类型。

* 不能使用instanceof来判断泛型类型，如`if (a instanceof Pair<String>)`是错误的。
* 不能强制类型转换泛型类型，如`Pair<String> p = (Pair<String>)a;`是错误的。
* getClass方法总是返回原始类型。

### 3.不能创建参数化类型的数组

不能实例化参数化类型的数组，如`var table = new Pair<String>[10];`是错误的。数组会记住它的元素类型，如果试图存储其它类型的元素就会抛出一个ArrayStoreException异常。

### 4.Varargs警告

上面讲到Java不支持泛型类型的数组。再讨论一个问题：向参数个数可变的方法传递一个泛型类型的实例。如下：

```java
public static <T> void addAll(Collection<T> coll, T... ts){
    for (T t : ts) coll.add(t);
}
```

实际上参数ts是一个数组，为了调用这个方法，Java虚拟机必须建立一个Pair<String>数组，这就违反了前面的规则。不过，对于这种情况，规则有所放松，只会得到一个警告，而不是错误。

可以采用两种方法来抑制这个警告。一种方法是为包含addAll调用的方法增加注解@SuppressWarnings("unchecked")。或者在Java7中，还可以用@SafeVarargs直接注解addAll方法：

```java
@SafeVarargs
public static <T> void addAll(Collection<T> coll, T... ts)
```

@SafeVarargs只能用于声明为static、final或private的构造器和方法。所有其他方法都可能被覆盖，使得这个注解没有什么意义。

### 5.不能实例化类型变量

### 6.不能构造泛型数组

### 7.泛型类的静态上下文中类型变量无效

### 8.不能抛出或捕获泛型类的实例

## 6.泛型类型的继承规则

在使用泛型类时，需要了解有关继承和子类型的一些规则。例如Employee是Manager的父类。但是Pair<Manager>不是Pair<Employee>的子类。泛型类可以拓展实现其它的泛型类。这一点，它们与普通的类没有什么区别。例如，ArrayList<T>类实现了List<T>接口，意味着，一个ArrayList<Manager>可以转换为一个List<Manager>。

