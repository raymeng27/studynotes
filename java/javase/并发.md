# 并发

# 一、线程

> 如今，人们往往都有多CPU的计算机。但是，并行执行的进程数目并不受限于CPU数目。操作系统会为每个进程分配CPU时间片，给人并行处理的感觉。
>
> 多线程程序在更低一层拓展了多任务的概念：单个程序看起来同时完成多个任务。每个任务在一个线程中执行，线程是控制线程的简称。如果一个程序可以同时运行多个线程，则称这个程序是多线程的。
>
> 多进程和多线程的区别在于每个进程都拥有自己的一整套变量，而线程则共享数据。这听起来似乎有些风险，不过，共享变量使线程之间的通信比进程之间的通信更有效，更容易。此外，与进程相比，线程更轻量级，创建，销毁一个线程比启动新进程的开销要小得多。

创建线程的简单例子：

* 将执行这个任务的代码放在一个类的run方法里，这个类要实现Runnable接口，Runnable接口非常简单，只有一个方法：

  ```java
  public interface Runnable {
      void run();
  }
  ```

  比如：

  ```java
  public class TaskRunnable implements Runnable {
      @Override
      public void run() {
          for (int i = 0; i < 100; i++) {
              System.out.println(i);
          }
      }
  }
  ```

* 从这个Runnable构造一个Thread对象

  ```java
  Thread t = new Thread(r);
  ```

* 启动线程

  ```java
  t.start();
  ```

Tips：不要调用Thread类或者Runnable对象的run方法。直接调用run方法只会在同一个线程中执行这个任务，而没有启动新的线程。应当调用Thread.start方法，这会创建一个执行run方法的新线程。

# 二、线程状态

> 线程有以下6种状态：
>
> * New（新建）
> * Runnable（可运行）
> * Blocked（阻塞）
> * Waiting（等待）
> * Timed waiting（计时等待）
> * Terminated（终止）
>
> 要确定一个线程的当前状态，只需要调用getState方法

## 1.新建线程

当用new操作符创建一个新线程时，如new Thread(r)，这个线程还没有开始运行。这意味着它的状态是新建（new）。当一个线程处于新建状态时，程序还没有开始运行线程中的代码。

## 2.可运行线程

一旦调用start方法，线程就处于可运行（runnable）状态。一个可运行的线程可能正在运行可能没有运行。要由操作系统为线程提供具体的运行时间。

## 3.阻塞和等待线程

当线程处于阻塞或等待状态时，它暂时是不活动的。它不运行任何代码，而且消耗最少的资源，要由线程调度器重新激活这个线程。具体细节取决于它是怎样到达非活动状态的。

* 当一个线程视图获取一个内部的对象锁（非java.util.concurrent中的Lock），而这个锁目前被其它线程占有，该线程就会被阻塞。当所有其他线程都释放了这个锁，并且线程调度器允许该线程持有这个锁时，它将变成非阻塞状态。
* 当线程等待另一个线程通知调度器出现一个条件时，这个线程会进入等待状态。调用Object.wait方法或Thread.join方法或者是Lock或Condition时就会出现这种情况。实际上，阻塞状态与等待状态并没有太大区别。
* 有几个方法有超时参数，调用这些方法会让线程进入计时等待（timed waiting）状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有Thread.sleep、Object.wait、Thread.join、Lock.tryLock以及Condition.await。

## 4.终止线程

线程会由于以下三个原因之一而终止：

* run方法正常退出，线程自然终止。
* 因为一个没有捕获的异常终止了run方法，使线程以外终止。
* 可以调用线程的stop方法杀死一个线程。不过stop方法已经被废弃。

# 三、线程属性

## 1.守护线程

通过调用t.setDaemon(true)将一个线程设置为守护线程。

## 2.线程名

使用setName方法为线程设置任何名字。

## 3.线程优先级

默认情况下，一个线程会继承构造它的那个线程的优先级，可以使用setPriority方法提高或降低任何一个线程的优先级。可以将优先级设置为MIN_PRIORITY(1)与MAX_PRIORITY(10)之间的任何值。NORM_PRIORITY定义为5。但是，线程的优先级高度依赖于系统。

# 四、同步

##  1.静态条件

在大多数实际的多线程应用中，两个活两个以上的线程需要共享对同一数据的存取。如果两个线程存取同一个对象，并且每个线程分别调用了一个修改对对想状态的方法，会发生什么？可以想见，这两个线程会相互覆盖。取决于线程访问数据的次序，可能会导致对象被破坏。这种情况通常称为静态条件。为了避免多线程破坏共享数据，必须学习如何同步存取。

## 2.锁对象

有两种机制可防止并发访问代码块。Java语言提供了一个synchronized关键字来达到这一个目的，另外Java5提供了一个ReentrantLock类。synchronized关键字会自动提供一个锁以及相关的条件，对于大多数需要显示锁的情况，这种机制功能很强大，也很便利。使用ReentrantLock保护代码块的基本结构如下：

```java
mylock.lock();
try{
    section...
}finally{
    mylock.unlock();
}
```

这个结构确保任何时刻只有以恶搞线程进入临界区。一旦一个线程锁定了锁对象，其他任何线程都无法通过lock语句。当其他线程调用lock时，他们会暂停，知道第一个线程释放这个锁对象。

## 3.synchronized关键字

在使用Lock和Condition对象时，锁和条件的要点为：

* 锁用来保护代码片段，一次只能有一个程序执行被保护的代码。
* 锁可以管理试图进入被保护代码段的线程。
* 一个锁可以有一个或多个相关联的条件对象。
* 每个条件对象管理那些已经进入被保护代码段但还不能运行的线程。

Lock和Condition接口允许程序员充分控制锁定，不过，大多数情况下，并不需要那样控制，完全可以使用Java语言内置的一种机制。从1.0版本开始，Java中的每个对象都有一个内部锁。如果一个方法声明时有synchronized关键字，那么对象的锁将保护整个方法，也就是说，要调用这个方法，线程必须获得内部对象锁。

```java
public synchronized void method(){
    method body...
}
```

等价于

```java
public void method(){
    this.intrinsicLock.lock();
    try(){
        method body...
    }
    finally(){
        this.intrinsicLock.unlock();
    }
}
```

## 4.同步块


